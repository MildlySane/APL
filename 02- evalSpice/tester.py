import numpy as np

#Class for Each Circuit Element
#The value of the elements, nodes it's connected to and name is stored in this
class CircuitElement:
    def __init__(self, name, node1, node2, value):
        self.name = name
        self.node1 = node1
        self.node2 = node2
        self.value = value

#Goes through filename and returns lists
#V-Voltage Sources
#I-Current Sources
#R-Resistors
#Nodes
def file_parse(filename):
    try:
        file=open(filename,"r")
    except:
        raise FileNotFoundError("File not found; give valid filename")
    
    V=[]
    I=[]
    R=[]
    Nodes=[]
    
    #Flag to check if ".end" appears in the circuit
    endflag=0

    #Take the pointer to after ".circuit" if it exists or raise error if it doesn't
    while 1:
        line=file.readline()
        if line:
            if ".circuit" not in line:
                continue
            break
        else:
            raise ValueError("Malformed Circuit File- No .circuit")
        
    lines=file.readlines()
    
    #This loop takes value from each line and puts data into corresponding lists
    #This mostly does the parsing
    for line in lines:
        if ".end" not in line:
            data=line.split()
            
            #ERROR: Same Element Name used twice
            if data[0] in V+I+R:
                raise ValueError("Malformed Circuit File- Element Repeats") #Check the error to be raised;this is if same name happens twice
            
            #Add node names to list Nodes
            else:
                if data[1] not in Nodes:
                    Nodes.append(data[1])
                if data[2] not in Nodes:
                    Nodes.append(data[2])

            #Add Voltage source to list V
            if data[0][0].upper()=="V":
                
                #ERROR: DC source not given
                if data[3]!="dc":
                    raise ValueError("Only DC Sources Allowed")
                
                V.append(CircuitElement(data[0],data[1],data[2],float(data[4])))
            
            #Add Current source to list I
            elif data[0][0].upper()=="I":
                
                #ERROR: DC Source not given
                if data[3]!="dc":
                    raise ValueError("Only DC Sources Allowed")
                
                I.append(CircuitElement(data[0],data[1],data[2],float(data[4])))
            
            #Add Resistor to list R
            elif data[0][0].upper()=="R":

                #If Resistance is 0, set it to a very small value
                if(float(data[3])==0):
                    data[3]=1e-10

                R.append(CircuitElement(data[0],data[1],data[2],float(data[3])))               
            
            #ERROR: Invalid Element
            else:
                raise ValueError("Only V,I,R allowed")
        
        else:
            endflag=1
            break
    
    #ERROR: ".end" not found in circuit
    if not endflag:
        raise ValueError("Malformed Circuit File- No .end")
    
    #ERROR: "GND" not given
    if 'GND' not in Nodes:
        raise ValueError("GND Not Given")
    
    return V,I,R,Nodes
            
#Creates Equation Matrices A and B from V,I,R,N generated by file_parse() function
def create_eqns(V,I,R,Nodes):
    
    #Dictionary mapping each Node to a number
    node_index={i:Nodes.index(i) for i in Nodes}

    #Dictionary Mapping each Voltage source to a number
    Vs_index={V[i].name:i for i in range(len(V))}

    #A Matrix in AX=B
    lhs=np.zeros((len(Nodes)+len(V),len(Nodes)+len(V)))

    #B Matrix in AX=B
    rhs=np.zeros(len(Nodes)+len(V))

    #Modifies A and B matrices for each Voltage Source
    for V_source in V:
        
        node1,node2,V_index=node_index[V_source.node1], node_index[V_source.node2],Vs_index[V_source.name]
        
        #Modifies LHS and RHS for the Voltage Equation (Auxillary Equation) across the voltage source
        lhs[len(Nodes)+V_index][node1]=1
        lhs[len(Nodes)+V_index][node2]=-1
        rhs[len(Nodes)+V_index]=V_source.value

        #Modifies LHS to add Voltage Source current in eqn
        lhs[node2][len(Nodes)+V_index]=-1
        lhs[node1][len(Nodes)+V_index]=1

    #Modifies A and B Matrices for each Current Source
    for I_source in I:
        
        node1,node2=node_index[I_source.node1], node_index[I_source.node2]
        rhs[node1]-=1*I_source.value
        rhs[node2]+=1*I_source.value
    
    #Modifies A and B for each resistor in R (Adds 1/Res term with correct sign)
    for Res in R:    
        
        node1,node2=node_index[Res.node1], node_index[Res.node2]

        lhs[node2][node2]+=1/float(Res.value)
        lhs[node2][node1]+=-1/float(Res.value)

        lhs[node1][node1]+=1/float(Res.value)
        lhs[node1][node2]+=-1/float(Res.value)
    
    #Equation for "GND" node- Set GND=0
    gnd=node_index["GND"]
    lhs[gnd]=lhs[gnd]*0
    lhs[gnd][gnd]=1
    rhs[gnd]=0

    return lhs,rhs,node_index,Vs_index

#Solves the system of linear equations A and B, then puts it into dictionaries to be returned
def equation_solve(A,B,Nodes,V,Node_index,Vs_index):
    
    #ERROR: Singular Matrix- Invalid Config of Voltage or Current Sources
    try:
        Result=np.linalg.solve(A,B)
    
    except np.linalg.LinAlgError:
        raise ValueError("Singular Matrix- No Solution Possible")
    
    #Creating Nodal Voltage and Voltage Source Current Dictionaries
    Node_V={Node:Result[Node_index[Node]] for Node in Nodes}
    Vs_Current={Vs.name:Result[len(Nodes)+Vs_index[Vs.name]] for Vs in V}

    return Node_V,Vs_Current

#Main Function- Calls the other functions to solve circuit
def evalSpice(filename):
    
    V,I,R,Nodes=file_parse(filename) #Store circuit elements in lists
    A,B,Node_index,Vs_index=create_eqns(V,I,R,Nodes) #Create the Coefficient Matrix and RHS Matrix for equations
    Node_V,Vs_Current=equation_solve(A,B,Nodes,V,Node_index,Vs_index) #Solve the System of Linear Equations, to be put as output

    return Node_V,Vs_Current

print(evalSpice("shorted.ckt"))